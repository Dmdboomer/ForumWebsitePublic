{"ast":null,"code":"// api.js\nexport const searchAPI = {\n  performSearch: async (term, startDate, endDate) => {\n    try {\n      // Validate term is provided\n      if (!term || typeof term !== 'string') {\n        throw new Error('Valid search term is required');\n      }\n\n      // Construct URL with proper base URL\n      const url = new URL(`${process.env.REACT_APP_API_BASE_URL || ''}/api/search`);\n      url.searchParams.append('term', term.trim());\n\n      // Only append dates if they are valid\n      if (startDate && !isNaN(new Date(startDate).getTime())) {\n        url.searchParams.append('startDate', new Date(startDate).toISOString());\n      }\n      if (endDate && !isNaN(new Date(endDate).getTime())) {\n        url.searchParams.append('endDate', new Date(endDate).toISOString());\n      }\n      const response = await fetch(url.toString(), {\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.message || `Request failed with status ${response.status}`);\n      }\n      const data = await response.json();\n\n      // Validate response structure\n      if (!Array.isArray(data)) {\n        throw new Error('Invalid response format from server');\n      }\n      return data.map(item => ({\n        id: item.id,\n        title: item.title,\n        date: item.date,\n        score: item.score,\n        leafCount: item.non_null_leaf_count,\n        popularity: item.popularity\n      }));\n    } catch (error) {\n      console.error('Search failed:', error);\n      throw error;\n    }\n  }\n};","map":{"version":3,"names":["searchAPI","performSearch","term","startDate","endDate","Error","url","URL","process","env","REACT_APP_API_BASE_URL","searchParams","append","trim","isNaN","Date","getTime","toISOString","response","fetch","toString","headers","ok","errorData","json","catch","message","status","data","Array","isArray","map","item","id","title","date","score","leafCount","non_null_leaf_count","popularity","error","console"],"sources":["/Users/yc/Documents/MainWebsiteTree/ActualWebsite/Algorithm+TopicSutff/algorithm-app/src/CodeHome/services/searchAPI.js"],"sourcesContent":["// api.js\nexport const searchAPI = {\n  performSearch: async (term, startDate, endDate) => {\n    try {\n      // Validate term is provided\n      if (!term || typeof term !== 'string') {\n        throw new Error('Valid search term is required');\n      }\n\n      // Construct URL with proper base URL\n      const url = new URL(`${process.env.REACT_APP_API_BASE_URL || ''}/api/search`);\n      url.searchParams.append('term', term.trim());\n      \n      // Only append dates if they are valid\n      if (startDate && !isNaN(new Date(startDate).getTime())) {\n        url.searchParams.append('startDate', new Date(startDate).toISOString());\n      }\n      if (endDate && !isNaN(new Date(endDate).getTime())) {\n        url.searchParams.append('endDate', new Date(endDate).toISOString());\n      }\n\n      const response = await fetch(url.toString(), {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.message || `Request failed with status ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      // Validate response structure\n      if (!Array.isArray(data)) {\n        throw new Error('Invalid response format from server');\n      }\n\n      return data.map(item => ({\n        id: item.id,\n        title: item.title,\n        date: item.date,\n        score: item.score,\n        leafCount: item.non_null_leaf_count,\n        popularity: item.popularity\n      }));\n    } catch (error) {\n      console.error('Search failed:', error);\n      throw error;\n    }\n  }\n};"],"mappings":"AAAA;AACA,OAAO,MAAMA,SAAS,GAAG;EACvBC,aAAa,EAAE,MAAAA,CAAOC,IAAI,EAAEC,SAAS,EAAEC,OAAO,KAAK;IACjD,IAAI;MACF;MACA,IAAI,CAACF,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QACrC,MAAM,IAAIG,KAAK,CAAC,+BAA+B,CAAC;MAClD;;MAEA;MACA,MAAMC,GAAG,GAAG,IAAIC,GAAG,CAAC,GAAGC,OAAO,CAACC,GAAG,CAACC,sBAAsB,IAAI,EAAE,aAAa,CAAC;MAC7EJ,GAAG,CAACK,YAAY,CAACC,MAAM,CAAC,MAAM,EAAEV,IAAI,CAACW,IAAI,CAAC,CAAC,CAAC;;MAE5C;MACA,IAAIV,SAAS,IAAI,CAACW,KAAK,CAAC,IAAIC,IAAI,CAACZ,SAAS,CAAC,CAACa,OAAO,CAAC,CAAC,CAAC,EAAE;QACtDV,GAAG,CAACK,YAAY,CAACC,MAAM,CAAC,WAAW,EAAE,IAAIG,IAAI,CAACZ,SAAS,CAAC,CAACc,WAAW,CAAC,CAAC,CAAC;MACzE;MACA,IAAIb,OAAO,IAAI,CAACU,KAAK,CAAC,IAAIC,IAAI,CAACX,OAAO,CAAC,CAACY,OAAO,CAAC,CAAC,CAAC,EAAE;QAClDV,GAAG,CAACK,YAAY,CAACC,MAAM,CAAC,SAAS,EAAE,IAAIG,IAAI,CAACX,OAAO,CAAC,CAACa,WAAW,CAAC,CAAC,CAAC;MACrE;MAEA,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACb,GAAG,CAACc,QAAQ,CAAC,CAAC,EAAE;QAC3CC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB;MACF,CAAC,CAAC;MAEF,IAAI,CAACH,QAAQ,CAACI,EAAE,EAAE;QAChB,MAAMC,SAAS,GAAG,MAAML,QAAQ,CAACM,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACzD,MAAM,IAAIpB,KAAK,CAACkB,SAAS,CAACG,OAAO,IAAI,8BAA8BR,QAAQ,CAACS,MAAM,EAAE,CAAC;MACvF;MAEA,MAAMC,IAAI,GAAG,MAAMV,QAAQ,CAACM,IAAI,CAAC,CAAC;;MAElC;MACA,IAAI,CAACK,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;QACxB,MAAM,IAAIvB,KAAK,CAAC,qCAAqC,CAAC;MACxD;MAEA,OAAOuB,IAAI,CAACG,GAAG,CAACC,IAAI,KAAK;QACvBC,EAAE,EAAED,IAAI,CAACC,EAAE;QACXC,KAAK,EAAEF,IAAI,CAACE,KAAK;QACjBC,IAAI,EAAEH,IAAI,CAACG,IAAI;QACfC,KAAK,EAAEJ,IAAI,CAACI,KAAK;QACjBC,SAAS,EAAEL,IAAI,CAACM,mBAAmB;QACnCC,UAAU,EAAEP,IAAI,CAACO;MACnB,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,gBAAgB,EAAEA,KAAK,CAAC;MACtC,MAAMA,KAAK;IACb;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}